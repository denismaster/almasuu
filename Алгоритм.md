## Алгоритм работы транслятора
Алгоритм трансляции состоит из следующих этапов:

1. Открытие и парсинг файла на _токены_ 
2. Анализ _токенов_ и построение _объектной модели программы_
3. Генерация _объектного кода_ на основе объектной модели и запись в файл.

### Открытие и парсинг файла на токены
В самом начале алгоритма, файл с кодом считывается и разбивается на массив строк. 
Пример разбиения:

_Файл code.asm_
```asm
mov ax, 1
mov cx, 0
```
Результат разбиения на строки:
```java
[
   "mov ax,1",
   "mov cx,0"
]
```
Следующим большим шагом идет парсинг каждой строки на _лексемы_ и формирование из лексем _токенов_.

**Лексема** - распознанная последовательность символов в тексте, которая имеет определенное значение.  
**Токен** - объект, который хранит в себе лексему, а также ее тип.
Пример разбиения:

`mov ax,  1`  - исходная строка файла
`["mov", "ax", "1"]` - разбитая на слова-лексемы.
Далее рассматриваем каждое слово и определяем его тип.

`"mov"` - команда, получаем `{Command, "mov"}` - полученный токен команды
`"ax"` - регистр, получаем `{Register, "ax"}` - токен регистра
`"1"` - какое-то значение, получаем `{Number, "1"}` - токен значения.

Аналогично определяются токены- директивы. В ходе анализа на токены комментарии исключаются. Если же тип лексемы не удалось определить, ей ставится значение "Other".

Все полученные токены с одной строки объединяются в набор `TokenLine`. Таким образом, каждой строке исходного файла соответствует набор `TokenLine`

Третий шаг - определение переменных и меток.

На данном этапе мы совершаем еще один проход по нашему файлу, но теперь по каждому набору токенов. 
При этом рассматриваются только те токены, у которых ранее не удалось установить тип(Other).
Правила определения:
-  Если значение лексемы состоит из 1 слова, а заканчивается на `:`,  при этом этого слова нет в списке меток, то мы нашли определение метки, меняем тип токена на Label.
-  Если значение лексемы не содержит двоеточия, при этом у нас  это слово есть уже в списке меток, то мы нашли ссылку на метку, ставим тип токена (LabelLink).
-  Если слова в списке нет, но при этом следующий токен является токеном сегмента( SEGMENT) или же конца сегмента (ENDS), то мы нашли сегмент (SegmentStart, SegmentEnds)
-  Если слова в списке нет, но следующий токен является директивой определения( DW или DB), то мы нашли переменную. (Variable)

При этом все найденные переменные, сегменты и метки запоминаются. После этого вновь проходим по набору токенов и меням тип токена у тех токенов, которые по факту ссылки на метку или на переменную, но при этом сами метки или переменные объявлены позже.

Если же в наборе остались нераспознанные токены - ругаемся на них.

Итоговый сформированный набор токенов, набор меток, сегментов и переменных является объектом `TokenParsingResult`, который далее(если нет ошибок) передается на этап анализа.

### Анализ токенов и построение объектной модели программы
Далее необходимо построить объектную модель программы - специальной структуры, которая будет содержать описание всей программы в виде объектов.

Типичная структура объектной модели на примере:

_Файл code.asm_
```asm
data segment
 db x 33
 dw y 42
data ends
code segment
start: mov ax, 1
mov cx, ax
ends
```

после токенизации и построения объектной модели примет следующий вид:

```java
[
   new DataSegment(
      new ByteDeclaration("x",33),
      new WordDeclaration("y",42)
   ),
   new CodeSegment(
      new LabelDeclaration("start"),
      new ImmediteateToRegisterMovCommand(Registers.AX, 1, isWord: false),
      new RegisterToRegisterMovCommand(Registers.CX, Registers.AX)
   )
]
```

Пример того, как набор токенов превращается в команду:

`{Command, "mov"}, {Register, "ax"}, {Number, "1"}` превращается в следующий объект:
`new ImRegMovCommand(ax, 1, false)`, причем последний аргумент false означает, что мы передаем байты, а не слова. Это потому, что число 1 меньше, чем 256.

Каждая команда, сегмент и т.д. имеют метод generateCode(), который выводит их машинный код.

Например, команда Im/Reg Mov с параметрами "AX" и FFC(word-слово, больше 256) выведет следующий  код:

`10111000 (код команды) 11111100 00001111 (следующие 16 бит это FFC в его машинном представлении, младший байт потом старший байт`

Если же команда принимает не непосредственные операнды или регистры, а косвенные адреса, переменные и метки, то происходит вычисление _**адреса**_ этих переменных и меток, который потом также вставляется в готовый машинный код.

В ходе анализа получаем объект ObjectModel. 

### Генерация _объектного кода_ на основе объектной модели и запись в файл.

Вызываем у объекта ObjectModel метод генерации кода, который рекурсивно вызовет его у дочерних объектов.

Формируется двоичный код. Готовые коды команд соединяются через пробел. Итоговая строка выводится в файл.
